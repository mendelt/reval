use crate::{expr::Expr, value::Value};
use rust_decimal::Decimal; 
use std::str::FromStr;

grammar;

match {
    "==" => OP_EQ,
    "!=" => OP_NEQ,
    ">" => OP_GT,
    "<" => OP_LT,
    ">=" => OP_GTE,
    "<=" => OP_LTE,
    "+" => OP_ADD,
    "-" => OP_SUB,
    "*" => OP_MULT,
    "/" => OP_DIV,
    "!" => OP_NOT,
    "and" => OP_AND,
    "or" => OP_OR,
    "if" => IF_KWD,
    "then" => THEN_KWD,
    "else" => ELSE_KWD,
    "is_some" => KWD_IS_SOME,
    "is_none" => KWD_IS_NONE,
    "int" => KWD_INT,
    "float" => KWD_FLOAT,
    "dec" => KWD_DEC,
    "," => COMMA,
    ":" => COLON,
    "(" => LPAREN,
    ")" => RPAREN,
    "[" => LBRACKET,
    "]" => RBRACKET,
    "{" => LBRACE,
    "}" => RBRACE,
    r#""([^"])*""# => STRING,
    r"i[+-]?[0-9]+" => INT,
    r"f[+-]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?" => FLOAT,
    r"d[+-]?[0-9]*\.?[0-9]+" => DECIMAL,
    "true" => TRUE,
    "false" => FALSE,
    "none" => NONE,
}
else {
    r"[a-zA-Z][_a-zA-Z0-9]*" => IDENT,
}

pub Expr: Expr = IfExpr;

IfExpr: Expr = {
    IF_KWD <iif:LogExpr> THEN_KWD <thn:LogExpr> ELSE_KWD <els:LogExpr> => Expr::iif(iif, thn, els),
    LogExpr
}

LogExpr: Expr = {
    <l:LogExpr> OP_AND <r:EqExpr> => Expr::and(l, r),
    <l:LogExpr> OP_OR <r:EqExpr> => Expr::or(l, r),
    EqExpr
}

EqExpr: Expr = {
    <l:EqExpr> OP_EQ <r:AddExpr> => Expr::eq(l, r),
    <l:EqExpr> OP_NEQ <r:AddExpr> => Expr::neq(l, r),
    <l:EqExpr> OP_GT <r:AddExpr> => Expr::gt(l, r),
    <l:EqExpr> OP_LT <r:AddExpr> => Expr::lt(l, r),
    <l:EqExpr> OP_GTE <r:AddExpr> => Expr::gte(l, r),
    <l:EqExpr> OP_LTE <r:AddExpr> => Expr::lte(l, r),
    AddExpr
}

AddExpr: Expr = {
    <l:AddExpr> OP_ADD <r:MultExpr> => Expr::add(l, r),
    <l:AddExpr> OP_SUB <r:MultExpr> => Expr::sub(l, r),
    MultExpr
}

MultExpr: Expr = {
    <l:MultExpr> OP_MULT <r:Term> => Expr::mult(l, r),
    <l:MultExpr> OP_DIV <r:Term> => Expr::div(l, r),
    Term
}

Term: Expr = {
    Func,
    Ref,
    Value => Expr::Value(<>),
    LPAREN <Expr> RPAREN
};

Func: Expr = {
    KWD_INT LPAREN <e:Expr> RPAREN => Expr::int(e),
    KWD_FLOAT LPAREN <e:Expr> RPAREN => Expr::float(e),
    KWD_DEC LPAREN <e:Expr> RPAREN => Expr::dec(e),
    KWD_IS_SOME LPAREN <e:Expr> RPAREN => Expr::is_some(e),
    KWD_IS_NONE LPAREN <e:Expr> RPAREN => Expr::is_none(e),
    OP_SUB LPAREN <e:Expr> RPAREN => Expr::neg(e),
    OP_NOT LPAREN <e:Expr> RPAREN => Expr::not(e),
}

Ref: Expr = <s:IDENT> => Expr::reff(<>);

Value: Value = {
    StringValue,
    IntValue,
    FloatValue,
    DecimalValue,
    BoolValue,
    VecValue,
    MapValue,
    NoneValue,
};

StringValue: Value = <s:STRING> => Value::sanitize_string(s);
IntValue: Value = <s:INT> => Value::Int(i128::from_str(&s[1..]).unwrap());
FloatValue: Value = <s:FLOAT> => Value::Float(f64::from_str(&s[1..]).unwrap());
DecimalValue: Value = <s:DECIMAL> => Value::Decimal(Decimal::from_str(&s[1..]).unwrap());
BoolValue: Value = {
    TRUE => Value::Bool(true),
    FALSE => Value::Bool(false)
};

VecValue: Value = LBRACKET <v0:(<Value> COMMA)*> <v1:Value?> RBRACKET => Value::Vec(v0.into_iter().chain(v1).collect());

MapItem: (String, Value) = <k:IDENT> COLON <v:Value> => (k.to_string(), v);
MapValue: Value = LBRACE <v0:(<MapItem> COMMA)*> <v1:MapItem?> RBRACE => Value::Map(v0.into_iter().chain(v1).collect());

NoneValue: Value = NONE => Value::None;
